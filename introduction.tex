\section{Introduction}
Many real world problems exhibit a composite structure consisting of multiple smaller problems which can be combined in many different configurations.
These types of problems lend themselves for a declarative approach as knowledge representations offers a transparent, natural and extendable model satisfying `The Principle of Elaboration Tolerance'~\citep{elaboration_tolerance}.
Delarative programming distinguishes itself by the ease with which declarative specifications can be adapted to variations in which subproblems are used, and in the way they are combined.

Conversely, the smaller problems in these composite structures are often already NP or coNP complete.
Combining these already complex problems often raises the computational complexity of the composite problem, up to a level where it cannot be expressed using first order logic. These problems become inherently higher order logic.
We study the \emph{Graph Mining} problem as an example problem of such a raise in complexity, and detail some of the techniques that can be used to handle this.
This includes the generalization of ad-hoc techniques as well as the combination of techniques from different logics.

Graph mining is a specific kind of \emph{frequent pattern mining}, which is one of the ``super-problems'' in Data Mining.~\cite{}
In its basic form it is the task of enumerating patterns which occur frequently in a dataset.
A first class of \emph{pattern mining} is \emph{unstructured mining}, such as \emph{itemset mining}, where the pattern is a set of items without any additional structural relation between the different items. 
Because it does not require any structure, the \emph{unstructured mining} task does not compose multiple smaller problems.
Therefore the rise in computational complexity associated with problem composition does not occur and the problem is even of propositional nature.
\citet{tias_original} have demonstrated how the \emph{itemset mining} problem can successfully be modeled in a declarative way using CP techniques.

In recent years, focus has shifted from unstructured mining towards structured mining, such as graph or sequence mining.
Here, the items being mined exhibit additional structure, for example the edge relation in the case of graph mining, or the order of elements in a sequence.
Graph mining has many applications; it is for example often used as a preprocessing step for machine learning algorithms~\citep{pattern_mining_classification}.
The additional structure required by the graph mining problem introduces subproblems within the graph mining problem: We need to specify when a graph occurs within other graphs, leading to the concept of homomorphism checks.
Likewise,\matthias{(also due to the additional structure)}, we need to represent the objects in the graph mining problem in a way that makes it non-obvious to say whether two objects are identical, which gives rise to subgraph isomorphism detection.
Many different interpretations can be given to these two problems\matthias{homomorphism checks and isomorphism detection}~ \citep{subtree_overview}, and in general these variations of the homomorphism and isomorphism concepts are NP-complete~\ref{}\matthias{referenties op te zoeken}.
While this gives rise to many wildly different algorithms in imperative languages~\citep{gspan,theta_subsumption}, these variations can be specified with only minimal changes using a declarative modelling approach.

In our case study of the graph mining problem, we start with from the mathematical model of graph mining, which is inherently higher order, and identify the following contributions:
\begin{compactitem}
\item We identify the higher order aspects of the graph mining problem and show how the problem can be modeled in IDP (which supports Existential Second Order and inductive definitions) in ASP ($\Sigma_{2}^{p}$), and in ProB (which supports higher order sets), proposing concrete modelling techniques such as the disjoint union technique. 
We also identify a set of desirable properties for a declarative encoding of the graph mining problem.
We compare how the different solutions perform, both with respect to the desirable properties as to computation time.
%\item We propose higher order language constructs for IDP and ProB extensions which greatly improve the ease of expressing the graph mining and other higher order problems.
%\item We indicate how to shift the burden of addressing the higher order aspects of the problem from modeler to the solver. 
\item We propose an encoding that closely follows the mathematical model of graph mining, and satisfies all desirable properties of a graph mining model.
We indicate how to shift the burden of addressing the higher order aspects of the problem using encoding techniques from modeler to the solver. 
Concretely, solver support is needed to translate the proposed higher order language constructs from the previous item to first order using e.g the disjoint union modeling technique.
We indicate how additional solver support can leverage these expressive constructs to work more efficient.
\end{compactitem}
%\todo{rewrite contributions to two points}
The paper is structured as follows: Section \ref{sec:formalization} introduces the formalization of graph mining, Section \ref{sec:modeling} introduces a logical model and discusses the primitives at the core of graph mining problem.
Then, Section \ref{sec:code} introduces graph mining encodings in IDP, ASP and ProB. Section \ref{sec:extension} discusses language extensions.
Section \ref{sec:related_work} discusses related work. Section \ref{sec:conclusion} draws conclusions and outlines possible future research directions.