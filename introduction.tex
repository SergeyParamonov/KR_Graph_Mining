% !TEX root = notes.tex
\section{Introduction}
\todo{Add references and a discussion of higher-order systems such as DLVHEX, HiLog, Alloy*}
Many real world problems exhibit a composite structure consisting of multiple smaller problems which can be combined in many different configurations.
These types of problems lend themselves for a declarative approach as knowledge representations offers a transparent, natural and extendable model satisfying `The Principle of Elaboration Tolerance'~\citep{elaboration_tolerance}.
Delarative programming distinguishes itself by the ease with which declarative specifications can be adapted to variations in which subproblems are used, and in the way they are combined.

Conversely, the smaller problems in these composite structures are often already NP or coNP complete.
Combining these already complex problems often raises the computational complexity of the composite problem, up to a level where it cannot be expressed using first order logic.
These problems become inherently higher order logic: We study the \emph{Graph Mining} problem as an example problem featuring such a raise in complexity.

Specification languages with support for higher oder logic exist, with different levels of support.
On the one hand, meta-programming, as known from Logic Programming~\citep{Abramson and Rogers 1989}, has inspired the introduction of higher-order atoms in DLVHex~\citep{?}  and the higher-order syntax in HiLog~\citep{?}.
As in Prolog, predicate symbols can be either constants (first-order case) or variables (second-oder case).
In the case of predicate variable symbols, these variables range over predicate names, and not the predicate space itself, essentially combining second-order syntax with first-order semantics. 
This is not enough to model the graph mining problem.

On the other hand, specification languages such as Alloy~\citep{?}, B~\citep{?}, TLA~\citep{?}, VDM~\citep{?} and Z~\citep{?}, that support state-based and machine-based formal methods typically extend predicate logic with sets and operators from relational algebra, offering higher order semantics.
ProB~\citep{?} is such a well-know system for Event-B.
%This level of support for higher-order logic is enough to model the graph mining problem.
We can express the graph mining problem in these languages directly using higher order, but in general these systems miss the flexibility to perform multiple different inferences such as model expansion and optimization without modifying the specification.
Furthermore, while some of these systems can express inductive definitions using either its completion or using a built-in transitive closure operator, this comes with a significant loss of readability.
Lastly, many of these systems are built directly on CP techniques and finite domain solvers, and consequently do not implement the recent revolutions in solving techniques such as CDCL.

For these reasons, we also look at specification languages that do not allow higher order syntax.
Examples of such languages are the IDP language and the ASP language.
For these languages, several techniques exist that allow the user to simulate higher order logic to model problems such as graph mining, potentially offering better performance than systems that allow higher order logic directly.

%We study the \emph{Graph Mining} problem as an example problem of such a raise in complexity, and detail some of the techniques that can be used to handle this.
%This includes the generalization of ad-hoc techniques as well as the combination of techniques from different logics.

Graph mining is a specific kind of \emph{frequent pattern mining}, 
%which is one of the ``super-problems'' in Data Mining.~\citep{?}
%In its basic form it is }
the task of enumerating patterns which occur frequently in a dataset.
A first class of \emph{pattern mining} is \emph{unstructured mining}, such as \emph{itemset mining}, where the pattern is a set of items without any additional structural relation between the different items. 
Because it does not require any structure, the \emph{unstructured mining} task does not compose multiple smaller problems.
Therefore the rise in computational complexity associated with problem composition does not occur and the problem is even of propositional nature.
\citet{tias_original} have demonstrated how the \emph{itemset mining} problem can successfully be modeled in a declarative way using CP techniques.

In recent years, focus has shifted from unstructured mining towards structured mining, such as graph or sequence mining.
Here, the items being mined exhibit additional structure, for example the edge relation in the case of graph mining, or the order of elements in a sequence.
%Graph mining has many applications; it is for example often used as a preprocessing step for machine learning algorithms}~\citep{pattern_mining_classification.
%\todo{This could easily be dropped, but for example Michael immediately asks the question 'where is graph mining used'}
The additional structure required by the graph mining problem introduces subproblems within the graph mining problem: We need to specify when a graph occurs within other graphs, leading to the concept of homomorphism checks.
%\Likewise, \matthias{(also due to the additional structure)}, we need to represent the objects in the graph mining problem in a way that makes it non-obvious to say whether two objects are identical, which gives rise to subgraph isomorphism detection.
Many different interpretations can be given to 
%these two problems
%\matthias{homomorphism checks and isomorphism detection}~
this problem\citep{subtree_overview}, and in general these variations of the homomorphism 
%\st{and isomorphism concepts }
concept
are NP-complete~\citep{}\matthias{referenties op te zoeken}.
While this gives rise to many wildly different algorithms in imperative languages~\citep{gspan,theta_subsumption}, these variations can be specified with only minimal changes using a declarative modelling approach.

In our case study of the graph mining problem, we start with from the mathematical model of graph mining, which is inherently higher order, and identify the following contributions:
\begin{compactitem}
\item We identify the higher order aspects of the graph mining problem and show how the problem can be modeled in IDP (which supports Existential Second Order and inductive definitions) in ASP ($\Sigma_{2}^{p}$), and in ProB (which supports higher order sets), proposing concrete modelling techniques such as the disjoint union technique. 
We also identify a set of desirable properties for a declarative encoding of the graph mining problem.
We compare how the different solutions perform, both with respect to the desirable properties as to computation time.
%\item We propose higher order language constructs for IDP and ProB extensions which greatly improve the ease of expressing the graph mining and other higher order problems.
%\item We indicate how to shift the burden of addressing the higher order aspects of the problem from modeler to the solver. 
\item We propose an encoding that closely follows the mathematical model of graph mining, and satisfies all desirable properties of a graph mining model.
We indicate how to shift the burden of addressing the higher order aspects of the problem using encoding techniques from modeler to the solver. 
Concretely, solver support is needed to translate the proposed higher order language constructs from the previous item to first order using e.g the disjoint union modeling technique.
We indicate how additional solver support can leverage these expressive constructs to work more efficient.
\end{compactitem}
%\todo{rewrite contributions to two points}
The paper is structured as follows: Section \ref{sec:formalization} introduces the formalization of graph mining, Section \ref{sec:modeling} introduces a logical model and discusses the primitives at the core of graph mining problem.
Then, Section \ref{sec:code} introduces graph mining encodings in IDP, ASP and ProB. Section \ref{sec:extension} discusses language extensions.
Section \ref{sec:related_work} discusses related work. Section \ref{sec:conclusion} draws conclusions and outlines possible future research directions.