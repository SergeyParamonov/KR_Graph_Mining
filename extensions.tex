\section{A faithful encoding}\label{sec:extension}
%\matthias{Here we will list the things we miss in each language, and introduce possible ways of implementing them and ways to learn from eachother}
%\matthias{How does ProB add HO, and what can we learn from them (and vice-versa)}
%In this section, we compile a list of missing language constructs, and introduce possible ways of implementing them and ways to learn from eachother.
%\subsection{Language}
%HO is sometimes criticized as being to expressive.
%Sometimes however, the additional structure HO exhibits allows solvers to perform better.
%For example, in this case HO preserves the local coherence and independence of the different examples, a property that the solver could leverage to become more efficient.
%\subsection{solver}

%\subsubsection{Oracles}
%\subsubsection{Benders decomposition}

\subsection{Faithful encoding}
In Listing~\ref{lst:faithful}, we now propose a new encoding for a language combining higher order logic support with the readability of inductive definitions.
This encoding is more faithful to the problem with respect to the definition given in Definition~\ref{def:gm2}.

In the vocabulary, a second order type called \lstinline{graph}, parametrized by two first order types \lstinline{node} and {\lstset{breakatwhitespace} \lstinline{label},} is declared as a tuple of a unary predicate \lstinline{vertex}/1, a binary predicate \lstinline{edge}/2, and a function \lstinline|label|.
Next, the higher order predicates (\lstinline|homomorphism|, \lstinline|reachable|, \lstinline|isPattern|, \lstinline|canonical_pattern|, \lstinline|positive|, and \lstinline|negative|) and function (\lstinline|template|) are declared.

Within the theory, higher order predicates are defined using the concept of templates as described by \cite{DBLP:journals/tplp/DassevilleHJD15}. % is used to define the higher order predicates.
The higher order arguments are decomposed using matching (e.g. line~\ref{lstline:matching}) or using dot notation (e.g. line~\ref{lstline:dot}).
Quantification over second order objects uses annotated quantifiers ($\exists_{SO}$ and $\forall_{SO}$) and must be typed (any unary predicate represents a type), e.g. line~\ref{lstline:exists}.

\begin{lstlisting}[mathescape,style=model,caption={Faithful encoding},label=lst:faithful, numbers=left]
Vocabulary V @\textbraceleft@
    type node
    type label
    so-type graph(node, label) of (vertex(node), edge(node,node), label(node):label)
    
    homomorphism(graph, graph)
    reachable(node,node, graph)
    isPattern(graph)
    canonical_pattern(graph)
    positive(graph)
    negative(graph)
    template:graph
@\textbraceright@ 

Theory T @\textbraceleft@ 
 @\textbraceleft@
 homomorphism((V1, Edge1, Label1), (V2, Edge2, Label2)) $\leftarrow$@\label{lstline:matching}@
     @\big(@$\exists_{SO}$ F [V1:V2] : ($\forall$ x, y : x $\neq$ y $\implies$ F(x) $\neq$ F(y)) $\wedge$@\label{lstline:exists}@
      ($\forall$ x, y : Edge1(x, y) $\implies$ Edge2(F(x), F(y))) $\wedge$
      ($\forall$ x : Label1(x) = Label2(F(x)))@\big)@.

 isomorph((V1, Edge1, Label1),(V2, Edge2, Label2)) $\leftarrow$
     @\big(@$\exists_{SO}$ F [V1:V2] : ($\forall$ y : y => $\exists$ x : F(x)=y) $\land$ 
      ($\forall$ x, y : x $\neq$ y $\implies$ F(x) $\neq$ F(y)) $\wedge$
      ($\forall$ x, y : Edge1(x, y) $\implies$ Edge2(F(x), F(y))) $\wedge$              
      ($\forall$ x, y : Edge2(x, y) $\implies$ $\exists$ fx, fy : Edge1(fx, fy) $\land$ x = F(fx) $\land$ y = F(fy)) $\wedge$
      ($\forall$ x : Label1(x) = Label2(F(x)))@\big)@.

 reachable(x, y, (Vertex, Edge, Label)) $\leftarrow$ Edge(x, y) $\lor$ Edge(y, x).
 reachable(x, y, (Vertex, Edge, Label)) $\leftarrow \exists$ z : reachable(x, z, (Edge, Label)) $\wedge$ reachable(z, y, (Edge, Label)).

 isPattern((Vertex, Edge, Label)) $\leftarrow$
     @\big(@($\forall x$: Vertex(x) $\implies$ template.Vertex(x)) $\land$@\label{lstline:dot}@
      ($\forall x,y$: Vertex(x) & Vertex(y) & template.vertex(x) & template.vertex(y) & template.Edge(x,y) $\implies$ Edge(x,y)) $\land$ 
      (@\#\textbraceleft@ Pos : positive(Pos) $\wedge$ homomorphism(P, Pos) @\textbraceright@ $\geq$ $N_{+}$) $\land$
      (@\#\textbraceleft@ Neg : negative(Neg) $\wedge$ homomorphism(P, Neg) @\textbraceright@ $\leq$ $N_{-}$) $\land$
      ($\forall$ x, y : reachable(x, y, P))@\big)@.
 @\textbraceright@
      
 $\forall$P : canonical_pattern(P) $\implies$ isPattern(P). 
 $\forall$P,P2 : canonical_pattern(P)$\wedge$canonical_pattern(P2)$\wedge$P$\neq$P2 $\implies$ $\neg$isomorph(P, P2).
@\textbraceright@ 
\end{lstlisting}

This encoding compactly specifies the graph mining problem, in a way that closely corresponds to its mathematical definition.
To allow inferences on this theory, extended solver support is necessary.
We now propose a way in which a solver can provide this additional support, and potentially even improve performance.

\subsubsection{Second order types}
We represent objects of any \lstinline|so-type| using the disjoint union technique, declaring a new first order type $id$ containing identifiers for the higher objects, e.g. \lstinline|graphId|.
\matthias{Using theory analysis, we determine whether the size of the second order type is bounded and if so, impose the same bound on the size of the type $id$.
If no such bound can be detected, we treat $id$ as an infinite type, relying on lazy grounding to create new $id$ objects when necessary and subsequently instantiate the required rules for the new $id$ object.}\todo{Matthias: Is it necessary to impose that different id's differ in some of their properties. (I don't think so). Would it help search (it might). It also makes comparing P=P2 easy.}

Next, as explained earlier, every occurrence of an object of type \lstinline|graph| is replaced by the correct identifier, and quantifications over this type are replaced by quantifications over the set of identifiers.

Lastly, every time a component of an object is accessed (e.g. \lstinline|Edge(x, y)|) it is replaced by a global function representing this component (i.e. \lstinline|Edge(gid, x, y)|).
%\matthias{In the graph mining example of Listing~\ref{lst:faithful}, the second order type \lstinline|graph| is }


\subsubsection{Second order quantifications $\exists_{SO}$/$\forall_{SO}$}
Second order quantifications such as $\exists_{SO}$ and $\forall_{SO}$ are supported using the concept of oracles as subsolvers.
First, all second order universal quantifications $\forall_{SO} X : \phi$ are rewritten to existential quantification $\neg \exists_{SO} X : \neg \phi$.
Suppose now that $\phi$ does not contain any further second order quantifications.
Then the above formula is an existential second order formula, which can be solved by a new instance of the \NP-solver.
Recently, \cite{AAAIW1612603} have identified an interface by which any solver can be nested within another solver.
%As \cite{AAAIW1612603} note, any solver that supports working with assumptions can be nested within another solver.
Because our \NP-solver conforms to this interface, we can modify the \NP-solver such that it calls a new instance of itself as an \emph{oracle} to evaluate the truth of these formulas.
The outer solver is called the \emph{top solver}, and the inner solver is called the \emph{subsolver} or \emph{oracle}.
As it is possible to nest these solvers arbitrarily deep, we can now solve a formula of the form $\exists_{SO} X : \phi$, regardless of whether $\phi$ contains any more second order quantifications.
Essentially, the \NP-solver becomes a \QBF-solver.

To set up a nested solver for a formula $\exists_{SO} X : \phi$, we must set up a vocabulary $V$ and a theory $T$ over $V$ for this solver. 
To this end, we first identify the variables $\Sigma$ used in $\phi$.
These variables $\Sigma$, together with the variable X from the quantification itself, are collected in the new vocabulary $V$. 
We call the free variables $\mathit{free}(\phi)$ the shared variables $\Sigma_s$.
By using the formula $\phi$ as the theory $T$, we conclude the setup of the nested subsolver.

Whenever we now need to evaluate the truth of a second order quantification, we simply call this oracle on vocabulary $V$ and theory $T$, providing it with a set of assumptions consisting of the values that the top solver assigns to the shared symbols $\Sigma_s$.
Depending on whether the subsolver succeeds or fails to find a model, we update the current interpretation of the top solver with the model or learn a new clause, as detailed by~\cite{AAAIW1612603}.
\todo{Benders decomposition~\citep{Benders}}

\todo{Toevoegen van een voorbeeld}

\subsection{Conclusion}
Higher order logic is sometimes criticized as being to expressive.
Sometimes however, the additional structure HO exhibits allows solvers to perform better.
For example, in the case of graph mining, higher order logic preserves the local coherence of graphs, and the independence of homomorphisms for the different examples, a property that a higher order solver can leverage in order to raise efficiency. 
Concretely, we predict that our subsolver technique will perform like the decomposed model from Section~\ref{sec:performance}, and expect a comparable performance gain over the first order model that uses only the disjoint union technique.

%Because these formulas are now written in existential second order, these can be solved by an \NP-solver.

\todo{oracles maken disjoint union terug efficient.}


%\subsubsection{Data representation}
%
%One possible way to solve these higher order theories is based on the disjoint union technique: 
%We automatically derive a \emph{disjoint union} specification from this higher order theory.
%By analyzing the different rules in the specification, the solver can derive that the only \matthias{one of the? (zie later)} higher order objects consist of an edge relation and a labeling function.
%It can then introduce these relations automatically, indexed by an identifier.
%Quantifications over these higher order objects become quantifications over these identifiers.
%\matthias{Furthermore the solver must also detect the existential quantification of the function $f$.
%This too leads to a disjoint union }
%
%Another way is to automatically introduce separate predicates and functions for each higher order object. 
%The solver subsequently replicates the necessary rules specified for these separate predicates and functions. \matthias{Dit gaat eigenlijk alleen in combinatie met de subsolver approach, omdat ik in het geval van een universele quantificatie over een predicaat waar gezocht wordt niet weet hoeveel keer ik de regels moet instantiëren.}
%
%\subsubsection{Negative contexts}
%First, the solver must detect existential higher order quantifications.
%When an existential quantification occurs in a negative context, 
%
%\matthias{Wanneer je (lokaal) herschrijft naar ESO komen al je coNP problemen (die je zéker in een subsolver moet steken) voor in negatieve context. Ik dacht dus ook dit apart te behandelen van de data representatie. Hier moet echter de kanttekening van boven bij gemaakt worden dat alleen in dit geval de replication methode haalbaar lijkt...}