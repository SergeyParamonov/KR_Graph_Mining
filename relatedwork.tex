\section{Related Work}
There is a number of research directions related to our work. We group them by what they have in common with our work and contrast the difference with each group.

\paragraph{Declarative Pattern Mining} There has been a lot of work on declarative pattern mining for unstructured data focused on: \textit{itemset mining} in the context of constraint programming \citep{tias_original,mining_cp_extra,tias_declarative_pattern_mining}, as well as in ASP \citep{asp_itemset} and SAT \citep{itemset_sat}, and \textit{tiling} in the context of ASP \citep{relational_decomposition} and of CP \citep{ranked_tiling}. 

Recently people started looking at the structured declarative pattern mining such as \textit{sequence mining} in CP \citep{cp_sequence_mining} and ASP \citep{rennes_asp_sequences}, and \textit{graph mining} in IDP \citep{ilp_graph_mining}. \sergey{I hope by this time IDP is very well explained and introduced, so I can just leave it as ``it is''} The main focus of these works is on the encoding techniques that allows one to encode model using existing language concepts and primitives, i.e., on the coding and execution but not on the model and language itself. From the KR point view, the latter work on graph mining is of a preliminary character, since it does not provide a deep knowledge representation analysis of the model with respect to the mismatch between higher order logical model and the executed model. Neither the most interesting practical case of discriminative mining was not investigated in detail, nor any comparison between ASP, IDP and ProB was provided. \sergey{Should it be phrased less harsh here?}

\citet{declarative_structured_language} proposed a generic framework that relies on the concept of \textit{operators} as building blocks of structured pattern mining. The key difference is in the design of the framework, it is inspired by the specialized algorithms and supposed to mimic their search techniques. Theoretically, the framework we have proposed in this paper can benefit from the ideas of operators and the search techniques described in the former, e.g., we can design a solver that would call a logical engine in a certain order keeping the context of the previous computations and therefore mimic the behaviour of the specialized algorithms, nevertheless using declarative specification for the operators.

\sergey{explain that higher order problem already occurs here}

\paragraph{Graph Mining} A number of classic algorithms has been developed over the years. They are designed to solve only particular topic and typically require complete rewriting of the algorithm to solve a new variation of the problem. For example the key component of structured mining \textit{the matching operator} exists in many versions: mining under homomorphism \citep{theta_subsumption} and under subgraph isomorphism \citep{gspan} for the general case of graphs, and for the subclass of trees there are three other matching operators \citep{subtree_overview}. Also the algorithms need to be adapted for the presence of various constraints, e.g., algorithms need to be changed to handle discriminative setting that is known to be particularly useful in applications \citep{pattern_mining_classification}

\paragraph{Graph Modeling} An interesting approach within CP paradigm is to to a domain specific primitives to the language. In the domain of graph combinatorial problems, there is a work in that directions called CP(graph) \citep{cp_graph}, where graph related primitives are integrated into the language: graph variables and certain types of graph constraints are supported. It is not however designed for mining problems and therefore does not discuss constraints for canonicity or matching. It is designed for only particular domain of graphs and it is unclear how to generalize it to our setting and other relational mining tasks.
